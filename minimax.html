<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>t√°ch vƒÉn b·∫£n & t·∫£i json</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
      padding: 10px;
      font-size: 14px;
      white-space: pre-wrap;
    }
    button {
      padding: 10px 20px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 20px;
    }
    button:hover {
      background: #218838;
    }
    .chunk {
      background: #f4f4f4;
      border-left: 4px solid #28a745;
      padding: 10px;
      margin-bottom: 10px;
    }
    .chunk.highlighted {
      background: #e6f3ff; /* m√†u n·ªÅn highlight */
      border-left: 4px solid #007bff; /* vi·ªÅn highlight */
    }
    .chunk-header {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .chunk-body {
      white-space: pre-wrap; /* gi·ªØ nguy√™n xu·ªëng d√≤ng */
      font-size: 14px;
      margin-bottom: 10px;
    }
    .copy-btn {
      background: #17a2b8;
      padding: 5px 10px;
      font-size: 12px;
    }
    .copy-btn:hover {
      background: #138496;
    }
    #chunkCount {
      font-weight: bold;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h2>‚úÇÔ∏è t√°ch vƒÉn b·∫£n ‚â§ 4500 k√Ω t·ª± & t·∫£i json</h2>
  <textarea id="inputText" placeholder="d√°n vƒÉn b·∫£n v√†o ƒë√¢y..."></textarea>
  <br>
  <button onclick="splitAndShow()">üì• t√°ch & hi·ªÉn th·ªã</button>
  <div id="chunkCount"></div>
  <div id="output"></div>

  <script>
    const MAX_LIMIT = 4500;

    // Danh s√°ch t·ª´ d·ªÖ nh·∫ßm l·∫´n v√† thay th·∫ø
    const confusableWords = {
      'im': 'ym'
    };

    // H√†m thay th·∫ø c√°c t·ª´ d·ªÖ nh·∫ßm l·∫´n
    function replaceConfusableWords(text) {
      let result = text;
      for (const [key, value] of Object.entries(confusableWords)) {
        const regex = new RegExp(`\\b${key}\\b`, 'g');
        result = result.replace(regex, value);
      }
      return result;
    }

    // Kh√¥i ph·ª•c n·ªôi dung textarea t·ª´ localStorage khi t·∫£i trang
    window.onload = () => {
      const savedText = localStorage.getItem('inputText');
      if (savedText) {
        document.getElementById('inputText').value = savedText;
        splitAndShow(); // T·ª± ƒë·ªông hi·ªÉn th·ªã c√°c ƒëo·∫°n ƒë√£ l∆∞u
      }
    };

    // T√°ch theo d·∫•u k·∫øt th√∫c c√¢u + gi·ªØ d√≤ng \n
    function splitBySentences(text) {
      const regex = /[^\n.?!„ÄÇÔºüÔºÅ]+[.?!„ÄÇÔºüÔºÅ]*\n?|[\n]/g;
      const result = [];
      let buffer = '';

      text.match(regex)?.forEach(part => {
        buffer += part;
        if (/[.?!„ÄÇÔºüÔºÅ]\s*$/.test(part) || part === '\n') {
          result.push(buffer);
          buffer = '';
        }
      });
      if (buffer.trim()) result.push(buffer);
      return result.filter(s => s.trim() !== '');
    }

    // Gom th√†nh ƒëo·∫°n ‚â§ 4500 k√Ω t·ª±, gi·ªØ nguy√™n \n
    function chunkSentences(sentences, limit) {
      const chunks = [];
      let buffer = '';

      for (let sentence of sentences) {
        const temp = buffer + sentence;
        if (temp.length <= limit) {
          buffer = temp;
        } else {
          if (buffer) chunks.push(buffer); // Kh√¥ng d√πng trim ƒë·ªÉ gi·ªØ \n
          buffer = sentence;
          if (sentence.length > limit) {
            while (sentence.length > limit) {
              chunks.push(sentence.slice(0, limit));
              sentence = sentence.slice(limit);
            }
            buffer = sentence;
          }
        }
      }
      if (buffer) chunks.push(buffer); // Kh√¥ng d√πng trim ƒë·ªÉ gi·ªØ \n
      return chunks;
    }

    // L·∫•y danh s√°ch c√°c ƒëo·∫°n ƒë√£ highlight t·ª´ localStorage
    function getHighlightedChunks() {
      const stored = localStorage.getItem('highlightedChunks');
      return stored ? JSON.parse(stored) : [];
    }

    // L∆∞u danh s√°ch c√°c ƒëo·∫°n ƒë√£ highlight v√†o localStorage
    function saveHighlightedChunk(index) {
      const highlightedChunks = getHighlightedChunks();
      if (!highlightedChunks.includes(index)) {
        highlightedChunks.push(index);
        localStorage.setItem('highlightedChunks', JSON.stringify(highlightedChunks));
      }
    }

    function splitAndShow() {
      let rawText = document.getElementById('inputText').value;
      const outputDiv = document.getElementById('output');
      const chunkCountDiv = document.getElementById('chunkCount');
      outputDiv.innerHTML = '';
      chunkCountDiv.textContent = '';

      // Chuy·ªÉn vƒÉn b·∫£n sang ch·ªØ th∆∞·ªùng
      rawText = rawText.toLowerCase();

      // Thay th·∫ø c√°c t·ª´ d·ªÖ nh·∫ßm l·∫´n
      rawText = replaceConfusableWords(rawText);

      // L∆∞u n·ªôi dung textarea (sau x·ª≠ l√Ω) v√†o localStorage
      localStorage.setItem('inputText', rawText);

      if (!rawText.trim()) {
        alert("‚ö†Ô∏è vui l√≤ng nh·∫≠p vƒÉn b·∫£n.");
        localStorage.removeItem('inputText'); // X√≥a n·∫øu textarea r·ªóng
        localStorage.removeItem('highlightedChunks'); // X√≥a highlight n·∫øu kh√¥ng c√≥ n·ªôi dung
        return;
      }

      const sentences = splitBySentences(rawText);
      const chunks = chunkSentences(sentences, MAX_LIMIT);
      const highlightedChunks = getHighlightedChunks();

      chunkCountDiv.textContent = `üî¢ ƒë√£ t√°ch ƒë∆∞·ª£c ${chunks.length} ƒëo·∫°n`;

      chunks.forEach((chunk, index) => {
        const div = document.createElement('div');
        div.className = 'chunk';
        if (highlightedChunks.includes(index)) {
          div.classList.add('highlighted'); // Kh√¥i ph·ª•c tr·∫°ng th√°i highlight
        }

        const header = document.createElement('div');
        header.className = 'chunk-header';
        header.textContent = `üß© ƒëo·∫°n ${index + 1} ‚Äì ${chunk.length} k√Ω t·ª±`;

        const body = document.createElement('div');
        body.className = 'chunk-body';
        body.innerText = chunk; // Gi·ªØ \n

        // N√∫t copy cho t·ª´ng ƒëo·∫°n
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'üìã copy';
        copyBtn.onclick = async () => {
          try {
            await navigator.clipboard.writeText(chunk);
            copyBtn.textContent = '‚úÖ ƒë√£ copy';
            div.classList.add('highlighted'); // Th√™m highlight khi copy
            saveHighlightedChunk(index); // L∆∞u v√†o localStorage
            setTimeout(() => {
              copyBtn.textContent = 'üìã copy';
            }, 2000);
          } catch (err) {
            alert('‚ö†Ô∏è l·ªói khi copy: ' + err);
          }
        };

        div.appendChild(header);
        div.appendChild(body);
        div.appendChild(copyBtn);
        outputDiv.appendChild(div);
      });

      // N√∫t t·∫£i JSON
      const btn = document.createElement('button');
      btn.textContent = 'üíæ t·∫£i json';
      btn.style.background = '#007bff';
      btn.onclick = () => {
        const blob = new Blob([JSON.stringify(chunks, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'split_text.json';
        a.click();
        URL.revokeObjectURL(url);
      };
      outputDiv.appendChild(btn);
    }
  </script>
</body>
</html>
